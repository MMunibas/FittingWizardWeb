/*
 * Copyright (c) 2016, Florent Hedin, Markus Meuwly, and the University of Basel
 * All rights reserved.
 *
 * The 3-clause BSD license is applied to this software.
 * see LICENSE.txt
 *
 */

package ch.unibas.charmmtools.files.topology;

import au.com.bytecode.opencsv.CSVReader;
import ch.unibas.charmmtools.internals.Angle;
import ch.unibas.charmmtools.internals.Atom;
import ch.unibas.charmmtools.internals.Bond;
import ch.unibas.charmmtools.internals.Dihedral;
import ch.unibas.charmmtools.internals.Improper;
import ch.unibas.charmmtools.internals.InternalCoordinates;
import java.io.CharArrayWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import org.apache.log4j.Logger;

/**
 * Abstract class for managing CHARMM topology files (RTF)
 * @author hedin
 */
public abstract class RTF {

    protected static final Logger logger = Logger.getLogger(RTF.class);
    
    /**
     * The name of the file for I/O
     */
    protected String fname = null;
    
    /**
     * The writer object holding data before writing
     */
    protected Writer writer = null;
    
    /**
     * This list will store data corresponding to atoms 
     * of an input file
     */
    protected List<?> InputDataAtoms = null;

    /**
     * Number of atoms in InputDataAtoms
     */
    protected int natom = 0;
    
    /**
     * Number of bonds calculated
     */
    protected int nbonds = 0;
    
    /**
     * Number of impropers calculated
     */
    protected int nimpr = 0;
    
    /**
     * Associative table associating a covalent radius to an atom type
     */
    protected HashMap<String, Double> covRad = null;
    
    /**
     * Associative table associating a mass to an atom type
     */
    protected HashMap<String, Double> atomicWeight = null;

    /**
     * Associative table associating to a hybridisation level an integer (order)
     * For carbons
     */
    protected HashMap<Integer, String> C_hybridList = new HashMap<Integer, String>() {
        private static final long serialVersionUID = 3109256773218160485L;
        {
            put(4, "sp3");
            put(3, "sp2");
            put(2, "sp");
        }
    };

    /**
     * Associative table associating to a hybridisation level an integer (order)
     * For oxygens
     */
    protected HashMap<Integer, String> O_hybridList = new HashMap<Integer, String>() {
        private static final long serialVersionUID = 3109256773218160485L;
        {
            put(2, "sp3");
            put(1, "sp2");
        }
    };

    /**
     * Associative table associating to a hybridisation level an integer (order)
     * For nitrogens
     */
    protected HashMap<Integer, String> N_hybridList = new HashMap<Integer, String>() {
        private static final long serialVersionUID = 3109256773218160485L;
        {
            put(4, "sp3");
            put(3, "sp3");
            put(2, "sp2");
            put(1, "sp");
        }
    };

    /**
     * List of atoms generated by class
     */
    protected List<Atom> atmTypeList = new ArrayList<>();
    
    /**
     * List of bonds generated by class
     */
    protected List<Bond> bndTypeList = new ArrayList<>();
    
    /**
     * List of angles generated by class
     */
    protected List<Angle> angTypeList = new ArrayList<>();
    
    /**
     * List of dihedrals generated by class
     */
    protected List<Dihedral> diheTypeList = new ArrayList<>();
    
    /**
     * List of impropers generated by class
     */
    protected List<Improper> imprTypeList = new ArrayList<>();
    
    /**
     * List of IC generated by class
     */
    protected List<InternalCoordinates> IC_List = new ArrayList<>();

    /**
     * constructor with a few basic atom types defined
     */
    public RTF() {
        this.covRad = new HashMap<String, Double>() {
            private static final long serialVersionUID = 3109256773218160485L;
            {
                put("C", 0.8);
                put("H", 0.4);
                put("O", 0.8);
                put("N", 0.8);
                put("S", 1.2);
                put("P", 1.2);
                put("F", 1.3);
            }
        };
        this.atomicWeight = new HashMap<String, Double>() {
            private static final long serialVersionUID = 3109256773218160485L;
            {
                put("C", 12.011);
                put("H", 1.008);
                put("O", 15.999);
                put("N", 14.007);
                put("S", 32.060);
                put("P", 30.974);
                put("F", 18.998);
            }
        };
        this.writer = new CharArrayWriter();
    }//ctor

    /**
     * constructor with extended atom types and their properties reas
     * from an external csv file
     * @param atomicInfo path to a CSV file containing the data
     */
    public RTF(String atomicInfo) {
        this.covRad = new HashMap<>();
        this.atomicWeight = new HashMap<>();
        readAtomicInfo(atomicInfo);
        this.writer = new CharArrayWriter();
    }//ctor

    /**
     * Method reading the csv file mentioned above
     * @param atInfoFileName the path to the CSV file
     */
    public final void readAtomicInfo(String atInfoFileName) {

        CSVReader csv = null;
        String[] dat = null;
        try {

            csv = new CSVReader(new FileReader(atInfoFileName));
            //ignore first line
            dat = csv.readNext();

            //iterate over csv file to get atomic data
            while ((dat = csv.readNext()) != null) {
                this.covRad.put(dat[1], Double.parseDouble(dat[2]));
                this.atomicWeight.put(dat[1], Double.parseDouble(dat[3]));
            }
   
        } catch (FileNotFoundException ex) {
            logger.error(ex);
        } catch (IOException ex) {
            logger.error(ex);
        }

    }//end readAtomicInfo

    /**
     * Get number of atoms
     * @return the natom
     */
    public int getNatom() {
        return natom;
    }

    /**
     * Get number of bonds 
     * @return the nbonds
     */
    public int getNbonds() {
        return nbonds;
    }

    /**
     * Get number of impropers
     * @return the nimpr
     */
    public int getNimpr() {
        return nimpr;
    }

    /**
     * Get the atom list
     * @return the atmTypeList
     */
    public final List<Atom> getAtmTypeList() {
        return atmTypeList;
    }

    /**
     * Get the bonds list
     * @return the bndTypeList
     */
    public final List<Bond> getBndTypeList() {
        return bndTypeList;
    }

    /**
     * Get the angles list
     * @return the angTypeList
     */
    public List<Angle> getAngTypeList() {
        return angTypeList;
    }

    /**
     * Get the dihedrals list
     * @return the diheTypeList
     */
    public List<Dihedral> getDiheTypeList() {
        return diheTypeList;
    }

    /**
     * Get the impropers list
     * @return the imprTypeList
     */
    public List<Improper> getImprTypeList() {
        return imprTypeList;
    }

    /**
     * Get the IC list
     * @return the IC_List
     */
    public List<InternalCoordinates> getIC_List() {
        return IC_List;
    }

    /**
     * Get the file name
     * @return the fname
     */
    public String getFname() {
        return fname;
    }

    /**
     * Get the mass for a given atom type
     * @param atname an atom type
     * @return the mass for the associated atom type
     */
    public double findMass(String atname) {
        return atomicWeight.get(atname);
    }

}//end of RTF class
